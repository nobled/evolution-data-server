/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8; fill-column: 160 -*- */
/*
 * Copyright (C) 2005 Novell Inc.
 *
 * Authors: Michael Zucchi <notzed@novell.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of version 2 of the GNU General Public
 * License as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <string.h>
#include <unistd.h>

#include "camel-folder-summary-disk.h"
#include "camel-view-summary-disk.h"

#include "camel-i18n.h"
#include "camel-record.h"
#include "camel-string-utils.h"

#include "camel-session.h"
#include "camel-folder.h"
#include "camel-folder-search.h"
#include "camel-store.h"

#include "camel-private.h"

/*
  A Berkeley DB based folder summary object.

  We have one global environment for the entire session.  This is stored
  relative to the session storage path under 'cameldbenv' (yes, apparently, not yet!).

  For each store, there are several tables, all stored in a single database
  file.  (Perhaps it should store them in a separate file each, but that would
  use more fd's?).

  Table: .#views

  - BTREE database
  - keys are full_name[\01viewid], there is one entry for
    each view of every folder, including the root view.
  - each record are as generated by CamelViewSummaryDisk.encode().
  - :'s in folder names are encoded (somehow?)

  Table: full_name

  - BTREE database
  - a custom sort function may be required to sort
    the keys in delivery order, or as close to as possible.
  - keys are the uid of the messages.
  - each record is as generated by the encode() method.
  - represents the 'root view' of each folder.

  Table: full_name\01viewid

  - BTREE database
  - same sort function must be used as the root view
  - each key is the uid of the message in the root view
  - all data items are empty

*/

#define w(x)
#define io(x)
#define d(x) /*(printf("%s(%d): ", __FILE__, __LINE__),(x))*/
#define v(x)

#define CDS_UNUSED_LIMIT (10)

#define CDS_CLASS(x) ((CamelFolderSummaryDiskClass *)((CamelObject *)x)->klass)
#define CFS_CLASS(x) ((CamelFolderSummaryClass *)((CamelObject *)x)->klass)
#define CFS(x) ((CamelFolderSummary *)x)
#define CDS(x) ((CamelFolderSummaryDisk *)x)

#define _PRIVATE(x) (((CamelFolderSummaryDisk *)x)->priv)

struct _CamelFolderSummaryDiskPrivate {
	/* do we have a sync job already launched? */
	volatile int sync_queued;

	/* These use the ref_lock */
	GHashTable *cache;
	GHashTable *changed;
};

typedef struct _CamelIteratorDisk CamelIteratorDisk;
struct _CamelIteratorDisk {
	CamelIterator iter;

	CamelFolderView *view;
	char *expr;

	GPtrArray *mis;
	int mis_index;

	DBC *cursor;
	DBT key;
	DBT data;

	CamelMessageInfo *current;

	int reset:1;
};

static CamelFolderSummaryClass *cds_parent;

#define LOCK_VIEW(v) CVSD_LOCK_ENV(((CamelFolderView *)v)->view->summary)
#define UNLOCK_VIEW(v) CVSD_UNLOCK_ENV(((CamelFolderView *)v)->view->summary)

static int
cds_dbt_cmp(DB *db, const DBT *a, const DBT *b)
{
	char *au, *bu;
	CamelFolderView *view;

	/* this costs, but saves us duplicating key compare code */
	au = g_alloca(a->size+1);
	memcpy(au, a->data, a->size);
	au[a->size] = 0;

	bu = g_alloca(b->size+1);
	memcpy(bu, b->data, b->size);
	bu[b->size] = 0;

	view = db->app_private;
	return CFS_CLASS(view->summary)->uid_cmp(au, bu, view->summary);
}

/* Initialise the database entries for a view, creating if necessary */
/* Must have viewsummary lock */
static void
cds_view_usedb(CamelFolderSummary *s, CamelFolderView *fview, DB_TXN *txn, CamelException *ex)
{
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)fview;
	CamelViewSummaryDisk *cvsd = (CamelViewSummaryDisk *)s->view_summary;
	int err;

	/* We keep track of the usage count of each view.  Once it reaches zero then
	   we put it in the 'unused' list; a candidate for closing to free up
	   some resources in a LRU fashion.

	   Note that the 'root view' is always opened all the time currently; although
	   it needn't be.
	*/

	if (view->unused) {
		view->unused = 0;
		e_dlist_remove(&view->ln);
	}

	if (view->db) {
		view->usecount++;
		return;
	}

	printf("opening view db '%s'\n", fview->view->vid);

	db_create(&view->db, cvsd->env, 0);
	view->db->app_private = view;
	view->db->set_bt_compare(view->db, cds_dbt_cmp);

	if (strchr(fview->view->vid, 1) == NULL) {
		/* root db, we just open it with create */
		err = view->db->open(view->db, txn, "folders", fview->view->vid, DB_BTREE, DB_CREATE, 0666);
		if (err != 0)
			camel_exception_setv(ex, 1, "creating root database failed: %s", db_strerror(err));
	} else {
		/* secondary db, if this is the first time we've opened it, we need to re-index */
		err = view->db->open(view->db, NULL, "folders", fview->view->vid, DB_BTREE, 0, 0666);
		// FIXME: must check we're getting the right return code ...
		if (err != 0) {
			view->db->close(view->db, 0);
			view->db = NULL;
			db_create(&view->db, cvsd->env, 0);
			view->db->app_private = view;
			view->db->set_bt_compare(view->db, cds_dbt_cmp);
			err = view->db->open(view->db, txn, "folders", fview->view->vid, DB_BTREE, DB_CREATE, 0666);
			if (err != 0)
				camel_exception_setv(ex, 1, "creating view database failed: %s", db_strerror(err));
			else
				// TODO: If this was a view that code other than load_header
				// created, we need to fire off a job to rebuild it?
				fview->view->rebuild = 1;
		}
	}

	view->usecount = 1;
}

/* must have ENV lock */
static void
cds_view_unusedb(CamelFolderSummary *s, CamelFolderView *fview)
{
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)fview;
	int len;

	g_assert(view->usecount > 0);
	view->usecount--;
	if (view->usecount == 0) {
		view->unused = 1;
		e_dlist_addtail(&CDS(s)->unused, &view->ln);
		len = e_dlist_length(&CDS(s)->unused);
		while (len >= CDS_UNUSED_LIMIT) {
			EDListNode *ln = e_dlist_remhead(&CDS(s)->unused);

			view = CFSD_VIEW_FROM_UNUSED(ln);
			printf("Flushing unused db for view '%s'\n", fview->view->vid);
			g_assert(view->usecount == 0);
			view->unused = 0;
			view->db->close(view->db, 0);
			view->db = NULL;
			len--;
		}
	}
}

static void
cds_load_views(CamelFolderSummaryDisk *cds, DB_TXN *txn, CamelException *ex)
{
	CamelIterator *iter;
	CamelViewDisk *dview;
	CamelFolderViewDisk *fview;

	g_assert(cds->summary.root_view == NULL);

	v(printf("Initialising views for folder '%s'\n", cds->summary.folder->full_name));

	iter = camel_view_summary_search(((CamelFolderSummary *)cds)->view_summary, cds->summary.folder->full_name, NULL, ex);
	if (iter == NULL)
		return;

	while ((dview = (CamelViewDisk *)camel_iterator_next(iter, ex))) {
		fview = (CamelFolderViewDisk *)camel_folder_view_new(CFS(cds), (CamelView *)dview);
		camel_folder_view_add(CFS(cds), (CamelFolderView *)fview, NULL);
	}
	camel_iterator_free(iter);

	/* We don't have any root view, so create it */
	if (cds->summary.root_view == NULL && !camel_exception_is_set(ex)) {
		dview = (CamelViewDisk *)camel_view_new(CFS(cds)->view_summary, CFS(cds)->folder->full_name);
		camel_view_summary_add(CFS(cds)->view_summary, (CamelView *)dview, ex);

		fview = (CamelFolderViewDisk *)camel_folder_view_new(CFS(cds), (CamelView *)dview);
		camel_folder_view_add(CFS(cds), (CamelFolderView *)fview, NULL);
		// FIXME: refcounts busted
	}
}

static int cds_save_info(CamelFolderSummaryDisk *s, CamelMessageInfo *mi, guint32 flags)
{
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)((CamelFolderSummary *)s)->root_view;
	CamelRecordEncoder *cre = camel_record_encoder_new();
	DBT key = { 0 }, data = { 0 };
	int err;

	CDS_CLASS(s)->encode((CamelFolderSummaryDisk *)s, (CamelMessageInfoDisk *)mi, cre);

	key.data = mi->uid;
	key.size = strlen(mi->uid);
	data.data = cre->out->data;
	data.size = cre->out->len;

	/* transaction? */
	LOCK_VIEW(view);
	err = view->db->put(view->db, NULL, &key, &data, flags);
	if (err != 0)
		view->db->err(view->db, err, "putting info '%s' into database", mi->uid);
	UNLOCK_VIEW(view);

	camel_record_encoder_free(cre);

	return err;
}

static CamelMessageInfo *cds_get_record(CamelFolderSummaryDisk *s, DBT *key, DBT *data)
{
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(s);
	char *uid;
	CamelMessageInfo *mi, *info;

	/* We are nominally converting a loaded disk record into a messageinfo.
	   We need to check if the particular record has already been loaded though.
	   And things are complicated by having to check if someone else has loaded
	   it while we were loading it - we could just use more locks? */

	uid = g_strndup(key->data, key->size);

	CAMEL_SUMMARY_LOCK(s, ref_lock);
	mi = g_hash_table_lookup(p->cache, uid);
	if (mi && mi->refcount != 0) {
		mi->refcount++;
		CAMEL_SUMMARY_UNLOCK(s, ref_lock);
		g_free(uid);
	} else {
		CamelRecordDecoder *crd;

		CAMEL_SUMMARY_UNLOCK(s, ref_lock);

		mi = camel_message_info_new((CamelFolderSummary *)s);
		mi->uid = uid;

		crd = camel_record_decoder_new(data->data, data->size);
		if (CDS_CLASS(s)->decode((CamelFolderSummaryDisk *)s, (CamelMessageInfoDisk *)mi, crd) != 0) {
			/* I guess we should then forcibly remove the record if we can't grok it */
			camel_record_decoder_free(crd);
			camel_message_info_free(mi);
			return NULL;
		}
		camel_record_decoder_free(crd);

		CAMEL_SUMMARY_LOCK(s, ref_lock);
		info = g_hash_table_lookup(p->cache, uid);
		if (info && info->refcount != 0) {
			info->refcount++;
		} else {
			info = NULL;
			g_hash_table_insert(p->cache, mi->uid, mi);
		}
		CAMEL_SUMMARY_UNLOCK(s, ref_lock);

		if (info) {
			camel_message_info_free(mi);
			mi = info;
		}
	}

	return mi;
}

#if 0
/* These have base implementations, it is only to override them or
   performance that they can be altered */
static int cds_add_array(CamelFolderSummary *s, GPtrArray *mis)
{
}

static void cds_remove_array(CamelFolderSummary *s, GPtrArray *mis)
{
}

static GPtrArray *cds_get_array(CamelFolderSummary *s, const GPtrArray *uids)
{
}

static void cds_message_info_free_array(CamelFolderSummary *s, GPtrArray *mis)
{
}

static CamelMessageInfo *cds_message_info_clone(CamelFolderSummary *s, const CamelMessageInfo *mi)
{
}

static CamelMessageInfo *cds_message_info_new_from_header(CamelFolderSummary *s, struct _camel_header_raw *h)
{
}

/* FIXME: must put back indexing crap into camelfoldersummary? */
static CamelMessageInfo *cds_message_info_new_from_parser(CamelFolderSummary *s, struct _CamelMimeParser *mp)
{
}

/* FIXME: must put back indexing crap into camelfoldersummary? */
static CamelMessageInfo *cds_message_info_new_from_message(CamelFolderSummary *s, struct _CamelMimeMessage *msg)
{
}

/* virtual accessors on messageinfo's */
static const void *cds_info_ptr(const CamelMessageInfo *mi, int id)
{
}

static guint32 cds_info_uint32(const CamelMessageInfo *mi, int id)
{
}

static time_t cds_info_time(const CamelMessageInfo *mi, int id)
{
}

static gboolean cds_info_user_flag(const CamelMessageInfo *mi, const char *id)
{
}

static const char cds_info_user_tag(const CamelMessageInfo *mi, const char *id)
{
}
#endif

/* This is only useful for mh and mbox ... */
static int
cds_uid_cmp(const void *ap, const void *bp, void *data)
{
	const char *a = ap, *b = bp;
	unsigned long av, bv;

	av = strtoul(a, NULL, 10);
	bv = strtoul(b, NULL, 10);

	if (av < bv)
		return -1;
	else if (av > bv)
		return 1;
	else
		return 0;
}

static int
cds_info_cmp(const void *ap, const void *bp, void *data)
{
	const CamelMessageInfo *a = ap;
	const CamelMessageInfo *b = bp;

	return CFS_CLASS(data)->uid_cmp(a->uid, b->uid, data);
}

static int cds_rename(CamelFolderSummary *s, const char *new)
{
	g_warning("rename not implemented");
	abort();
}

/* need to track a free to force a flush? */
/* wrong!  its already too late, a child class may have freed items */
static void cds_message_info_free(CamelMessageInfo *mi)
{
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(mi->summary);

	/* we can have uid-less 'cloned' infos from the app */
	if (mi->uid) {
		CAMEL_SUMMARY_LOCK(mi->summary, ref_lock);
		g_hash_table_remove(p->cache, mi->uid);
		CAMEL_SUMMARY_UNLOCK(mi->summary, ref_lock);
	}

	cds_parent->message_info_free(mi);
}

/* These functions handle changed infos, added infos and removed ones
   respectively.  The update all of the embedded view indices as appropriate. */

// FIXME: We must use transactions for them all!!
// Their scope must cover the original put too!

// FIXME: some locking wouldn't go astray either

/* TODO:
   If we know what flags have changed, we can highly optimise trash and junk
   views, but whatever eh */

static int
cds_update_view_add(CamelFolderViewDisk *view, const CamelMessageInfo *mi)
{
	int res = 0;

	if (camel_folder_search_match(view->view.iter, mi, NULL)) {
		DBT key = { 0 }, data = { 0 };
		CamelException ex = { 0 };

		key.data = (void *)camel_message_info_uid(mi);
		key.size = strlen(key.data);
		res = -1;

		LOCK_VIEW(view);
		cds_view_usedb(view->view.summary, (CamelFolderView *)view, NULL, &ex);
		if (ex.id == 0) {
			res = view->db->put(view->db, NULL, &key, &data, DB_NOOVERWRITE);
			if (res == 0) {
				d(printf("  just added a new match\n"));
				view->view.view->total_count++;
				// FIXME: update counts
				// FIXME: Update change info?
				camel_change_info_add(view->view.changes, mi);
			}
		} else
			camel_exception_clear(&ex);
		cds_view_unusedb(view->view.summary, (CamelFolderView *)view);
		UNLOCK_VIEW(view);

		if (res == 0)
			camel_view_changed(view->view.view);
	}

	return res;
}

static int
cds_update_view_remove(CamelFolderViewDisk *view, const CamelMessageInfo *mi)
{
	int res = -1;
	DBT key = { 0 };
	CamelException ex = { 0 };

	key.data = (void *)camel_message_info_uid(mi);
	key.size = strlen(key.data);

	LOCK_VIEW(view);
	cds_view_usedb(view->view.summary, (CamelFolderView *)view, NULL, &ex);
	if (ex.id == 0) {
		res = view->db->del(view->db, NULL, &key, 0);
		if (res == 0) {
			d(printf("  we had it, bye byte\n"));
			view->view.view->total_count--;
			// FIXME: update counts
			camel_change_info_remove(view->view.changes, mi);
		} else if (res != DB_NOTFOUND) {
			/* I can fill some data integrity issues coming on ... */
		}
	} else
		camel_exception_clear(&ex);
	cds_view_unusedb(view->view.summary, (CamelFolderView *)view);
	UNLOCK_VIEW(view);

	if (res == 0)
		camel_view_changed(view->view.view);

	return res;
}

static int cds_update_views_change(CamelFolderSummaryDisk *cds, CamelMessageInfo *mi)
{
	CamelFolderViewDisk *view;
	int res = 0;

	for (view = (CamelFolderViewDisk *)((CamelFolderSummary *)cds)->views.head;
	     view->view.next;
	     view = (CamelFolderViewDisk *)view->view.next) {
		d(printf("updating uid '%s' for secondary index '%s'\n", camel_message_info_uid(mi), view->view.vid));

		/* static searches, we only scan immutable data, so no changes need to be re-checked */
		if (!view->view.is_static) {
			if (camel_folder_search_match(view->view.iter, mi, NULL))
				res = cds_update_view_add(view, mi);
			else
				res = cds_update_view_remove(view, mi);
		}

		/* FIXME: How do we detect values changed in the view, and emit appropriate changed events?
		   Do we just leave it to the root view changed event? */
	}

	res = 0;

	return res;
}

static int cds_update_views_add(CamelFolderSummaryDisk *cds, CamelMessageInfo *mi)
{
	CamelFolderViewDisk *view;
	int res;

	view = (CamelFolderViewDisk *)((CamelFolderSummary *)cds)->views.head;
	while (((CamelFolderView *)view)->next) {
		res = cds_update_view_add(view, mi);
		view = (CamelFolderViewDisk *)view->view.next;
	}

	res = 0;

	return res;
}

static int cds_update_views_remove(CamelFolderSummaryDisk *cds, CamelMessageInfo *mi)
{
	CamelFolderViewDisk *view;
	int res = 0;

	view = (CamelFolderViewDisk *)((CamelFolderSummary *)cds)->views.head;
	while (((CamelFolderView *)view)->next) {
		res = cds_update_view_remove(view, mi);
		view = (CamelFolderViewDisk *)view->view.next;
	}

	res = 0;

	return res;
}

static int cds_add(CamelFolderSummary *s, void *o)
{
	CamelMessageInfo *mi = o;
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(s);
	int res;

	/* NOOVERWRITE ensures we dont get duplicates */

	res = cds_save_info((CamelFolderSummaryDisk *)s, mi, DB_NOOVERWRITE);

	if (res == 0) {
		CAMEL_SUMMARY_LOCK(s, ref_lock);
		g_hash_table_insert(p->cache, mi->uid, mi);
		CAMEL_SUMMARY_UNLOCK(s, ref_lock);
		cds_parent->add(s, mi);
		cds_update_views_add((CamelFolderSummaryDisk *)s, mi);
	}

	/* TODO: if it failed, or maybe even otherwise, put it in a queue for later adding? */

	return res;
}

static int cds_remove(CamelFolderSummary *s, void *o)
{
	CamelMessageInfo *mi = o, *oldmi;
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)s->root_view;
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(s);
	DBT key = { 0 };
	int res;

	CAMEL_SUMMARY_LOCK(s, ref_lock);
	g_hash_table_remove(p->cache, mi->uid);
	oldmi = g_hash_table_lookup(p->changed, mi->uid);
	if (oldmi) {
		g_hash_table_remove(p->changed, mi->uid);
		g_assert(oldmi == mi);
		g_assert(mi->refcount > 1);
		mi->refcount--;
	}
	CAMEL_SUMMARY_UNLOCK(s, ref_lock);

	/* Should foldersummary.remove() return some NOTFOUND code? */

	// FIXME: transactions with view update?

	key.data = mi->uid;
	key.size = strlen(mi->uid);
	LOCK_VIEW(view);
	res = view->db->del(view->db, NULL, &key, 0);
	UNLOCK_VIEW(view);

	/* We never had it anyway, ignore it */
	if (res == DB_NOTFOUND)
		return -1;

	if (res == 0) {
		res = cds_update_views_remove((CamelFolderSummaryDisk *)s, mi);
	} else {
		/* failed, now what? */ ;
		view->db->err(view->db, res, "removing info '%s' from database", mi->uid);
		res = 0;
	}

	cds_parent->remove(s, mi);

	return res;
}

static void cds_clear(CamelFolderSummary *s)
{
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(s);
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)s->root_view;

	LOCK_VIEW(view);

	view->db->truncate(view->db, NULL, NULL, 0);

	/* FIXME: other views? */
	/* FIXME: counts? */

	UNLOCK_VIEW(s->root_view);

	CAMEL_SUMMARY_LOCK(s, ref_lock);

	g_hash_table_destroy(p->cache);
	p->cache = g_hash_table_new(g_str_hash, g_str_equal);
	g_hash_table_destroy(p->changed);
	p->changed = g_hash_table_new(g_str_hash, g_str_equal);

	CAMEL_SUMMARY_UNLOCK(s, ref_lock);

	cds_parent->clear(s);
}

static void *cds_get(CamelFolderSummary *s, const char *uid)
{
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(s);
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)s->root_view;
	DBT key = { 0 }, data = { 0 };
	CamelMessageInfo *mi;
	int res;

	CAMEL_SUMMARY_LOCK(s, ref_lock);
	mi = g_hash_table_lookup(p->cache, uid);
	if (mi && mi->refcount != 0) {
		mi->refcount++;
		CAMEL_SUMMARY_UNLOCK(s, ref_lock);
		return mi;
	} else {
		mi = NULL;
	}
	CAMEL_SUMMARY_UNLOCK(s, ref_lock);

	key.data = (char *)uid;
	key.size = strlen(uid);
	data.flags = DB_DBT_MALLOC;

	LOCK_VIEW(view);
	res = view->db->get(view->db, NULL, &key, &data, 0);
	UNLOCK_VIEW(view);

	if (res == 0) {
		mi = cds_get_record((CamelFolderSummaryDisk *)s, &key, &data);
		if (data.data)
			free(data.data);
	}

	return mi;
}

/* Search & iterators, flags0 is flags to use on first key, and flags1 what to use after that
   if we need to go again - i.e. we got the header key or secondary index mismatch */
static const CamelMessageInfo *cds_iterator_step(void *mitin, guint32 flags0, guint32 flags1, CamelException *ex)
{
	CamelIteratorDisk *mit = mitin;
	CamelFolderViewDisk *root = (CamelFolderViewDisk *)mit->view->summary->root_view;
	CamelMessageInfo *mi;
	int res;

	if (mit->cursor == NULL)
		return NULL;

	if (mit->current) {
		camel_message_info_free(mit->current);
		mit->current = NULL;
	}

	/* Iterates over all keys in either the primary or secondary index.
	   For secondary indices we then also have to lookup in the main
	   index for the actual content.  Easy peasy. */

	/* We lock the root 'view', but all views are the same environment anyway */
	LOCK_VIEW(root);

	do {
		res = mit->cursor->c_get(mit->cursor, &mit->key, &mit->data, flags0);
		if (res == DB_NOTFOUND)
			goto done;
		else if (res != 0)
			goto done_fail;

		flags0 = flags1;

		if ((CamelFolderViewDisk *)mit->view != root) {
			res = root->db->get(root->db, NULL, &mit->key, &mit->data, 0);
			if (res == DB_NOTFOUND) {
				g_warning("Secondary index mismatch!  Eek!");
			} else if (res != 0)
				goto done_fail;
		}
	} while (res != 0);

	UNLOCK_VIEW(root);

	mi = cds_get_record((CamelFolderSummaryDisk *)mit->view->summary, &mit->key, &mit->data);
	mit->current = mi;

	return mi;

done_fail:
	// FIXME: find a good translator string
	camel_exception_setv(ex, 1, "operation failed: %s", db_strerror(res));
done:
	UNLOCK_VIEW(root);

	return NULL;
}

static const void *cds_iterator_next(void *mitin, CamelException *ex)
{
	CamelIteratorDisk *mit = mitin;
	const CamelMessageInfo *mi;

	mi = cds_iterator_step(mitin, mit->reset?DB_FIRST:DB_NEXT, DB_NEXT, ex);
	mit->reset = 0;

	return mi;
}

static void cds_iterator_reset(void *mitin)
{
	CamelIteratorDisk *mit = mitin;

	mit->reset = 1;
}

static void cds_iterator_free(void *mitin)
{
	CamelIteratorDisk *mit = mitin;
	CamelFolder *folder;

	if (mit->cursor) {
		LOCK_VIEW(mit->view);
		mit->cursor->c_close(mit->cursor);
		cds_view_unusedb(mit->view->summary, mit->view);
		UNLOCK_VIEW(mit->view);
		if (mit->data.data)
			free(mit->data.data);
		if (mit->key.data)
			free(mit->key.data);
	}
	
	if (mit->current)
		camel_message_info_free(mit->current);

	/* Need to unref the view first, since unreffing the folder
	   may free everything under us */
	folder = mit->view->summary->folder;
	camel_folder_view_unref(mit->view);
	camel_object_unref(folder);
}

static CamelIteratorVTable cds_iterator_vtable = {
	cds_iterator_free,
	cds_iterator_next,
	cds_iterator_reset,
};

static struct _CamelIterator *cds_search(CamelFolderSummary *s, const char *vid, const char *expr, CamelIterator *subset, CamelException *ex)
{
	CamelIteratorDisk *mit;
	CamelFolderViewDisk *view;

	/* We find the right index to search on then use that.  If this view
	   isn't defined or available, then we return an empty set */

	view = (CamelFolderViewDisk *)camel_folder_view_get(s, vid);
	if (view == NULL)
		return camel_message_iterator_infos_new(g_ptr_array_new(), TRUE);

	/* We assume subset is still in the summary, we should probably re-check? */

	if (subset) {
		/* we also assume subset is in the view ... */
		camel_folder_view_unref((CamelFolderView *)view);
		if (expr && expr[0])
			return (CamelIterator *)camel_folder_search_search(s->search, expr, subset, ex);
		else
			return subset;
	} else {
		/* The summary has no ref on the folder so we need to ref that instead */

		mit = camel_iterator_new(&cds_iterator_vtable, sizeof(*mit));
		mit->view = (CamelFolderView *)view;
		camel_object_ref(s->folder);

		LOCK_VIEW(view);
		cds_view_usedb(s, (CamelFolderView *)view, NULL, ex);
		if (view->db->cursor(view->db, NULL, &mit->cursor, 0) != 0) {
			cds_view_unusedb(s, (CamelFolderView *)view);
			mit->cursor = NULL;
		} else {
			mit->key.flags = DB_DBT_REALLOC;
			mit->data.flags = DB_DBT_REALLOC;
		}

		UNLOCK_VIEW(view);

		if (expr && expr[0])
			return (CamelIterator *)camel_folder_search_search(s->search, expr, (CamelIterator *)mit, ex);
		else
			return (CamelIterator *)mit;
	}
}

#if 0
// see comments in view_build_all 
static void
cds_view_rebuild(CamelFolderSummary *s, CamelFolderViewDisk *view, CamelException *ex)
{
	CamelIterator *iter;
	const CamelMessageInfo *info;
	DBT key = { 0 }, data = { 0 };
	int res;

	printf("building secondary index for new view '%s'\n", ((CamelFolderView *)view)->vid);

	/* Rebuild a secondary index.  We just store empty records,
	   with the matching keys only */

	iter = camel_folder_summary_search(s, NULL, view->view.expr, NULL, ex);
	if (iter == NULL)
		return;

	// This should be transaction protected

	while ((info = camel_iterator_next(iter, ex))) {
		key.data = (void *)camel_message_info_uid(info);
		key.size = strlen(key.data);

		LOCK_VIEW(view);
		res = view->db->put(view->db, NULL, &key, &data, 0);
		if (res == 0) {
			view->touched = 1;
			view->view.total_count++;
			// FIXME: update other counts
		}
		UNLOCK_VIEW(view);
	}
	camel_iterator_free(iter);

	printf(" %d total matches\n", view->view.total_count);
}
#endif

static void
cds_view_build_all(CamelFolderSummaryDisk *cds, CamelException *ex)
{
	CamelFolderViewDisk *view, *root = (CamelFolderViewDisk *)cds->summary.root_view;
	GPtrArray *build = g_ptr_array_new();
	int i;

	/* So, two possibilities here:
	   We iterator over all messages and match every view one by one
	   or
	   We search each view and add them.

	   The first should be better because we only iterate the full
	   set once, and should have good locality of reference for
	   everything anyway.

	   The second might be better, if we can somehow optimise
	   the search better than iterating over each message anyway.
	   Currently we don't, so the first should be better, and that is what
	   we're doing here.  (in reality they're probably the same).  Got that?!
	*/

	v(printf("Checking for views to rebuild:\n"));

	/* FIXME: lockit */
	for (view = (CamelFolderViewDisk *)((CamelFolderSummary *)cds)->views.head;
	     ((CamelFolderView *)view)->next;
	     view = (CamelFolderViewDisk *)((CamelFolderView *)view)->next) {
		if (view->view.view->rebuild) {
			v(printf(" rebuilding view %s:%s\n", CFS(cds)->folder->full_name, view->view.vid));
			// FIXME: ref it
			g_ptr_array_add(build, view);
			view->view.view->rebuild = 0;
		}
	}

	if (build->len) {
		CamelIterator *iter;
		const CamelMessageInfo *info;

		camel_operation_start(NULL, ngettext("Building view", "Building views", build->len));

		iter = camel_folder_summary_search((CamelFolderSummary *)cds, NULL, NULL, NULL, ex);
		while ((info = camel_iterator_next(iter, ex))) {
			if (root->view.view->total_count)
				camel_operation_progress(NULL, (i++)*100/root->view.view->total_count);

			for (i=0;i<build->len;i++)
				cds_update_view_add(build->pdata[i], info);
		}
		camel_iterator_free(iter);

		camel_operation_end(NULL);

		// fixme unref 'em
	} else {
		v(printf(" none!\n"));
	}

	g_ptr_array_free(build, TRUE);
}

static void
cds_view_add(CamelFolderSummary *s, CamelFolderView *fview, CamelException *ex)
{
	cds_parent->view_add(s, fview, ex);
	return;

#if 0
	CamelFolderViewDisk *view = (CamelFolderViewDisk *)fview;
	struct _camel_disk_env *env;

	/* We get called both from startup code loading the list of
	   folders we have, and from adding a new view.

	   If the env is set on the view, we're from the loading code,
	   so no need to save the folder list entry, otherwise
	   we must save it */

	cds_parent->view_add(s, fview, ex);
	if (camel_exception_is_set(ex) || view->env)
		return;

	env = get_env((CamelService *)s->folder->parent_store, ex);
	if (env == NULL)
		return;

	LOCK_ENV(env);
	cds_view_usedb(s, fview, NULL, ex);
	if (fview->vid != NULL)
		cds_view_unusedb(s, fview);
	UNLOCK_ENV(env);

	if (!camel_exception_is_set(ex))
		cds_view_save(CDS(s), view, NULL, ex);
#if 0
	DB_TXN *txn;
	int err;

	LOCK_ENV(env);
	err = env->env->txn_begin(env->env, NULL, &txn, 0);
	UNLOCK_ENV(env);
	if (err != 0) {
		camel_exception_setv(ex, 1, "cannot create transcation: %s", db_strerror(err));
	} else {
#endif
#if 0

		LOCK_ENV(env);
		if (!camel_exception_is_set(ex))
			txn->commit(txn, 0);
		else
			txn->abort(txn);
		UNLOCK_ENV(env);
	}
#endif
#endif
	// fIXME: unref env
}

static void
cds_view_remove(CamelFolderSummary *s, CamelFolderView *view)
{
	/* We don't do anything here yet, we will check the 'delete' flag when we unref, so
	   we can cleanly destroy the database */
	cds_parent->view_remove(s, view);
}

static void
cds_view_free(CamelFolderSummary *s, CamelFolderView *view)
{
	v(printf("freeing view/closing db '%s'\n", view->vid?view->vid:"root view"));

	LOCK_VIEW(view);

	if (((CamelFolderViewDisk *)view)->unused)
		e_dlist_remove(&((CamelFolderViewDisk *)view)->ln);

	if (((CamelFolderViewDisk *)view)->db)
		((CamelFolderViewDisk *)view)->db->close(((CamelFolderViewDisk *)view)->db, 0);

	if (view->view->deleted) {
		DB *db;

		v(printf("The view '%s' was deleted, doing it\n", view->view->vid));

		db_create(&db, ((CamelViewSummaryDisk *)s->view_summary)->env, 0);
		db->remove(db, "folders", view->view->vid, 0);
	}

	UNLOCK_VIEW(view);

	cds_parent->view_free(s, view);
}

/* ********************************************************************** */

/* After we have some changes, we run a job in another thread to flush them away
   We sleep for a bit to see if any more changes are pending, then go for it */

struct _sync_msg {
	CamelSessionThreadMsg msg;

	CamelFolderSummaryDisk *summary;
};

static void
cds_sync_run(CamelSession *session, CamelSessionThreadMsg *msg)
{
	struct _sync_msg *m = (struct _sync_msg *)msg;
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(m->summary);

	/* hmm, i like threads! */
	/* FIXME: must poll with a cancellation fd actually */
	sleep(2);

	p->sync_queued = FALSE;

	printf(" sync thread timeout, flushing changes\n");
	camel_folder_summary_disk_sync(m->summary, &msg->ex);
}

static void
cds_sync_free(CamelSession *session, CamelSessionThreadMsg *msg)
{
	struct _sync_msg *m = (struct _sync_msg *)msg;

	camel_object_unref(((CamelFolderSummary *)m->summary)->folder);
}

static CamelSessionThreadOps cds_sync_ops = {
	cds_sync_run,
	cds_sync_free,
};

static void
cds_info_changed(CamelMessageInfo *mi, int sysonly)
{
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(mi->summary);
	int dosync = 0;

	CAMEL_SUMMARY_LOCK(mi->summary, ref_lock);
	if (g_hash_table_lookup(p->changed, mi->uid) == NULL) {
		mi->refcount++;
		g_hash_table_insert(p->changed, mi->uid, mi);
		if (!p->sync_queued)
			p->sync_queued = dosync = 1;
	}
	CAMEL_SUMMARY_UNLOCK(mi->summary, ref_lock);

	if (dosync) {
		struct _sync_msg *m;
		CamelSession *session = ((CamelService *)mi->summary->folder->parent_store)->session;

		printf("queuing sync job\n");

		/* we have to ref the folder as it is the owner of the summary too */
		m = camel_session_thread_msg_new(session, &cds_sync_ops, sizeof(*m));
		m->summary = (CamelFolderSummaryDisk *)mi->summary;
		camel_object_ref(((CamelFolderSummary *)m->summary)->folder);
		camel_session_thread_queue(session, &m->msg, 0);
	}
}

static void cds_encode(CamelFolderSummaryDisk *cds, CamelMessageInfoDisk *mi, CamelRecordEncoder *cde)
{
	const CamelSummaryReferences *refs;
	const CamelSummaryMessageID *id;
	int i;
	CamelTag *tag;
	CamelFlag *flag;

	/* read-only header section.
	   Untyped stream of binary represents each item in a code-known order.

	   New field entries MUST only ever be added to the end of a
	   given section, this lets the data structure automatically
	   be backward & forward compatible.  If fields become
	   obsolete they should be written as empty/0 rather than
	   removed, until a version bump (and even then usually).
	*/

	camel_record_encoder_start_section(cde, CFSD_SECTION_HEADERS, 0);

	camel_record_encoder_int32(cde, camel_message_info_size(mi));
	camel_record_encoder_timet(cde, camel_message_info_date_sent(mi));
	camel_record_encoder_timet(cde, camel_message_info_date_received(mi));
	camel_record_encoder_string(cde, camel_message_info_subject(mi));
	camel_record_encoder_string(cde, camel_message_info_from(mi));
	camel_record_encoder_string(cde, camel_message_info_to(mi));
	camel_record_encoder_string(cde, camel_message_info_cc(mi));
	camel_record_encoder_string(cde, camel_message_info_mlist(mi));

	refs = camel_message_info_references(mi);
	id = camel_message_info_message_id(mi);
	
	camel_record_encoder_int32(cde, refs?refs->size + 1: 1);
	camel_record_encoder_int64(cde, id?id->id.id:0);
	if (refs) {
		for (i=0;i<refs->size;i++)
			camel_record_encoder_int64(cde, refs->references[i].id.id);
	}

	camel_record_encoder_end_section(cde);

	/* variable size/content flags section */
	camel_record_encoder_start_section(cde, CFSD_SECTION_FLAGS, 0);
	camel_record_encoder_int32(cde, camel_message_info_flags(mi));

	flag = (CamelFlag *)camel_message_info_user_flags(mi);
	if (flag) {
		camel_record_encoder_int32(cde, camel_flag_list_size(&flag));
		for (;flag;flag=flag->next)
			camel_record_encoder_string(cde, flag->name);
	} else {
		camel_record_encoder_int32(cde, 0);
	}

	tag = (CamelTag *)camel_message_info_user_tags(mi);
	if (tag) {
		camel_record_encoder_int32(cde, camel_tag_list_size(&tag));
		for (;tag;tag=tag->next) {
			camel_record_encoder_string(cde, tag->name);
			camel_record_encoder_string(cde, tag->value);
		}
	} else {
		camel_record_encoder_int32(cde, 0);
	}

	camel_record_encoder_end_section(cde);
}

static int cds_decode(CamelFolderSummaryDisk *cds, CamelMessageInfoDisk *mi, CamelRecordDecoder *cdd)
{
	int tag, ver, count, i;
	const char *s, *v;
	int res = -1;

	camel_record_decoder_reset(cdd);
	while ((tag = camel_record_decoder_next_section(cdd, &ver)) != CR_SECTION_INVALID) {
		switch (tag) {
		case CFSD_SECTION_HEADERS:
			/* decode header/static data */
			mi->info.size = camel_record_decoder_int32(cdd);
			mi->info.date_sent = camel_record_decoder_timet(cdd);
			mi->info.date_received = camel_record_decoder_timet(cdd);
			mi->info.subject = camel_pstring_strdup(camel_record_decoder_string(cdd));
			mi->info.from = camel_pstring_strdup(camel_record_decoder_string(cdd));
			mi->info.to = camel_pstring_strdup(camel_record_decoder_string(cdd));
			mi->info.cc = camel_pstring_strdup(camel_record_decoder_string(cdd));
			mi->info.mlist = camel_pstring_strdup(camel_record_decoder_string(cdd));
			count = camel_record_decoder_int32(cdd);
			if (count>0)
				mi->info.message_id.id.id = camel_record_decoder_int64(cdd);
			if (count>1) {
				count--;
				mi->info.references = g_malloc(sizeof(*mi->info.references) + (sizeof(CamelSummaryMessageID) * count));
				mi->info.references->size = count;
				for (i=0;i<count;i++) {
					mi->info.references->references[i].id.id = camel_record_decoder_int64(cdd);
					g_assert(mi->info.references->references[i].id.id != mi->info.message_id.id.id);
				}
			}
			/* we only need CDS_HEADERS for a valid struct */
			res = 0;
			break;
		case CFSD_SECTION_FLAGS:
			/* decode flags/dynamic data */
			mi->info.flags = camel_record_decoder_int32(cdd);
			count = camel_record_decoder_int32(cdd);
			for (i=0;i<count;i++) {
				s = camel_record_decoder_string(cdd);
				if (*s)
					camel_flag_set(&mi->info.user_flags, s, 1);
			}
			count = camel_record_decoder_int32(cdd);
			for (i=0;i<count;i++) {
				s = camel_record_decoder_string(cdd);
				v = camel_record_decoder_string(cdd);
				if (*s)
					camel_tag_set(&mi->info.user_tags, s, v);
			}
			break;
		}
	}

	return res;
}

static void
cds_sync(CamelFolderSummaryDisk *cds, GPtrArray *infos, CamelException *ex)
{
	CamelFolderViewDisk *root = (CamelFolderViewDisk *)((CamelFolderSummary *)cds)->root_view;
	int i;

	/* TODO: use transactions? */
	/* TODO: what to do about failures? */

	camel_operation_start(NULL, _("Storing changes"));

	for (i=0;i<infos->len;i++) {
		camel_operation_progress(NULL, i*100/infos->len);
		cds_save_info(cds, (CamelMessageInfo *)infos->pdata[i], 0);
		cds_update_views_change(cds, (CamelMessageInfo *)infos->pdata[i]);
	}

	LOCK_VIEW(root);
	if (root->db)
		root->db->sync(root->db, 0);
	UNLOCK_VIEW(root);

	camel_view_summary_disk_sync((CamelViewSummaryDisk *)CFS(cds)->view_summary, ex);

	camel_operation_end(NULL);
}

static void
camel_folder_summary_disk_class_init(CamelFolderSummaryDiskClass *klass)
{
	cds_parent = (CamelFolderSummaryClass *)camel_folder_summary_get_type();

	((CamelFolderSummaryClass *)klass)->folderview_sizeof = sizeof(CamelFolderViewDisk);

	((CamelFolderSummaryClass *)klass)->uid_cmp = cds_uid_cmp;
	((CamelFolderSummaryClass *)klass)->info_cmp = cds_info_cmp;

	((CamelFolderSummaryClass *)klass)->rename = cds_rename;

	((CamelFolderSummaryClass *)klass)->add = cds_add;
	((CamelFolderSummaryClass *)klass)->remove = cds_remove;
	((CamelFolderSummaryClass *)klass)->clear = cds_clear;
	((CamelFolderSummaryClass *)klass)->message_info_free = cds_message_info_free;

	((CamelFolderSummaryClass *)klass)->info_changed = cds_info_changed;

	((CamelFolderSummaryClass *)klass)->get = cds_get;

	((CamelFolderSummaryClass *)klass)->search = cds_search;

	((CamelFolderSummaryClass *)klass)->view_add = cds_view_add;
	((CamelFolderSummaryClass *)klass)->view_remove = cds_view_remove;
	((CamelFolderSummaryClass *)klass)->view_free = cds_view_free;

	klass->encode = cds_encode;
	klass->decode = cds_decode;

	klass->sync = cds_sync;
}

static void
camel_folder_summary_disk_init(CamelFolderSummaryDisk *o)
{
	o->priv = g_malloc0(sizeof(*o->priv));
	o->priv->cache = g_hash_table_new(g_str_hash, g_str_equal);
	o->priv->changed = g_hash_table_new(g_str_hash, g_str_equal);

	e_dlist_init(&o->unused);
}

static void
camel_folder_summary_disk_finalise(CamelObject *obj)
{
	CamelFolderSummaryDisk *cds = (CamelFolderSummaryDisk *)obj;
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(cds);

	/* FIXME: empty cache? */
	g_hash_table_destroy(p->cache);
	g_free(p);
}

CamelType
camel_folder_summary_disk_get_type(void)
{
	static CamelType type = CAMEL_INVALID_TYPE;
	
	if (type == CAMEL_INVALID_TYPE) {
		type = camel_type_register(camel_folder_summary_get_type(), "CamelFolderSummaryDisk",
					   sizeof (CamelFolderSummaryDisk),
					   sizeof (CamelFolderSummaryDiskClass),
					   (CamelObjectClassInitFunc) camel_folder_summary_disk_class_init,
					   NULL,
					   (CamelObjectInitFunc) camel_folder_summary_disk_init,
					   (CamelObjectFinalizeFunc) camel_folder_summary_disk_finalise);
	}
	
	return type;
}

static void
setup_views(CamelFolderSummary *s)
{
	CamelException ex = { 0 };

	camel_folder_view_create(s, "vfolder-0", " (and         (match-all (system-flag  \"Flagged\"))        ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-1", " (or    	(match-all (header-starts-with \"Subject\"  \"Avvist posting til no.annonser\"))          	(match-all (header-starts-with \"Subject\"  \"Feil i posting til no.annonser\"))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-2", " (and    	(match-all (or (header-matches \"To\"  \"au@usenet.no\") 	    	       (header-matches \"Cc\"  \"au@usenet.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-3", " (and   (match-all (header-contains \"From\"  \"daemon\"))            (match-all (or (header-starts-with \"To\"  \"postmaster\") 	    	       (header-starts-with \"Cc\"  \"postmaster\")))                  (match-all (or (header-ends-with \"To\"  \"usenet.no\") 	    	       (header-ends-with \"Cc\"  \"usenet.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-4", " (or            (match-all (or (header-ends-with \"To\"  \"moderators.isc.org\") 	    	       (header-ends-with \"Cc\"  \"moderators.isc.org\")))                  (match-all (or (header-ends-with \"To\"  \"moderators.usenet.no\") 	    	       (header-ends-with \"Cc\"  \"moderators.usenet.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-5", " (or    	(match-all (or (header-matches \"To\"  \"vaktmester@usenet.no\") 	    	       (header-matches \"Cc\"  \"vaktmester@usenet.no\")))          	(match-all (or (header-matches \"To\"  \"vaktmeister@usenet.no\") 	    	       (header-matches \"Cc\"  \"vaktmeister@usenet.no\")))          	(match-all (or (header-matches \"To\"  \"postmaster@usenet.no\") 	    	       (header-matches \"Cc\"  \"postmaster@usenet.no\")))          	(match-all (or (header-matches \"To\"  \"postmaster@general.usenet.no\") 	    	       (header-matches \"Cc\"  \"postmaster@general.usenet.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-6", " (and    	(match-all (or (header-matches \"To\"  \"abuse@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"abuse@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-7", " (and    	(match-all (or (header-matches \"To\"  \"ansatte@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"ansatte@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-8", " (or    	(match-all (or (header-contains \"To\"  \"drift@ifi.uio.no\") 	               (header-contains \"Cc\"  \"drift@ifi.uio.no\")))          	(match-all (or (header-contains \"To\"  \"drift@piazza.ifi.uio.no\") 	               (header-contains \"Cc\"  \"drift@piazza.ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"ifi-cd@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"ifi-cd@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"ijk@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"ijk@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"hostmaster@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"hostmaster@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"mr.find@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"mr.find@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"postmaster@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"postmaster@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"timekeeper@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"timekeeper@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-9", " (or    	(match-all (or (header-matches \"To\"  \"drift-internt@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"drift-internt@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"drift-internt@piazza.ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"drift-internt@piazza.ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-10", " (or    	(match-all (or (header-matches \"To\"  \"is@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"is@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"iq@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"iq@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-11", " (and    	(match-all (or (header-matches \"To\"  \"operator@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"operator@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-12", " (and   (match-all (header-matches \"From\"  \"postmaster@ifi.uio.no\"))    	(match-all (or (header-matches \"To\"  \"postmaster@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"postmaster@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-13", " (or    	(match-all (or (header-matches \"To\"  \"root@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"root@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-14", " (or   (match-all (header-matches \"From\"  \"store@ifi.uio.no\"))   ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-15", " (and   (match-all (header-matches \"From\"  \"news@ifi.uio.no\"))   ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-16", " (and   (match-all (header-contains \"From\"  \"owner\"))    	(match-all (header-contains \"Subject\"  \"admin request\"))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-17", " (or    	(match-all (or (header-matches \"To\"  \"drift@matnat.uio.no\") 	    	       (header-matches \"Cc\"  \"drift@matnat.uio.no\")))          	(match-all (or (header-matches \"To\"  \"stue-drift@matnat.uio.no\") 	    	       (header-matches \"Cc\"  \"stue-drift@matnat.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-18", " (and    	(match-all (or (header-matches \"To\"  \"cerebrum-commits@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"cerebrum-commits@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-19", " (or    	(match-all (or (header-matches \"To\"  \"cerebrum-developers@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"cerebrum-developers@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"noreply@sourceforge.net\") 	    	       (header-matches \"Cc\"  \"noreply@sourceforge.net\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-20", " (or    	(match-all (or (header-matches \"To\"  \"cerebrum-drift@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"cerebrum-drift@usit.uio.no\")))                  (match-all (or (header-starts-with \"To\"  \"cerebrum@\") 	    	       (header-starts-with \"Cc\"  \"cerebrum@\")))          	(match-all (or (header-matches \"To\"  \"cerebrum.bruker@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"cerebrum.bruker@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-21", " (and    	(match-all (or (header-matches \"To\"  \"cerebrum-logs@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"cerebrum-logs@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-22", " (and    	(match-all (or (header-matches \"To\"  \"cerebrum-uio@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"cerebrum-uio@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-23", " (and    	(match-all (or (header-matches \"To\"  \"imap-core@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"imap-core@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-24", " (or    	(match-all (or (header-matches \"To\"  \"lk-alle@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"lk-alle@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"lk-mn@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"lk-mn@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-25", " (and   (match-all (header-contains \"From\"  \"root@mail-lb\"))   ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-26", " (and    	(match-all (or (header-matches \"To\"  \"postklient@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"postklient@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-27", " (or    	(match-all (or (header-matches \"To\"  \"postmaster@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"postmaster@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"listearkiv@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"listearkiv@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"mailman-owner@lister.uio.no\") 	    	       (header-matches \"Cc\"  \"mailman-owner@lister.uio.no\")))          	(match-all (or (header-matches \"To\"  \"mister.mailman@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"mister.mailman@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"mister.exim@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"mister.exim@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-28", " (and    	(match-all (or (header-matches \"To\"  \"postmaster-core@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"postmaster-core@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-29", " (and    	(match-all (or (header-matches \"To\"  \"postmaster-logs@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"postmaster-logs@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-30", " (and    	(match-all (or (header-contains \"To\"  \"postmaster\") 	               (header-contains \"Cc\"  \"postmaster\")))          	(match-all (or (header-contains \"To\"  \"uio.no\") 	               (header-contains \"Cc\"  \"uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-31", " (or    	(match-all (or (header-matches \"To\"  \"studit-drift@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"studit-drift@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"utskriftsbetaling@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"utskriftsbetaling@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"utskriftskvote@admin.uio.no\") 	    	       (header-matches \"Cc\"  \"utskriftskvote@admin.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-32", " (or    	(match-all (or (header-matches \"To\"  \"unix-core@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"unix-core@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"sikkerhet@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"sikkerhet@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"daily-core@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"daily-core@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-33", " (or    	(match-all (or (header-matches \"To\"  \"unix-drift@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"unix-drift@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"down@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"down@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"samba@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"samba@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"fms@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"fms@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"utskrift@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"utskrift@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"drift@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"drift@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"priss@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"priss@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"unix-harddrift@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"unix-harddrift@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-34", " (or    	(match-all (or (header-matches \"To\"  \"ureg2000@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"ureg2000@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"ureg2000-core@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"ureg2000-core@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-35", " (or    	(match-all (or (header-matches \"To\"  \"usenet@uio.no\") 	    	       (header-matches \"Cc\"  \"usenet@uio.no\")))          	(match-all (or (header-matches \"To\"  \"usenet@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"usenet@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"usenet@readme.uio.no\") 	    	       (header-matches \"Cc\"  \"usenet@readme.uio.no\")))          	(match-all (or (header-matches \"To\"  \"ntb@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"ntb@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"newsmaster@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"newsmaster@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-36", " (and   (match-all (header-matches \"From\"  \"news@usit.uio.no\"))   ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-37", " (or    	(match-all (or (header-matches \"To\"  \"alle@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"alle@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"gt-core@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"gt-core@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"usit-sapp@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"usit-sapp@usit.uio.no\")))          	(match-all (or (header-matches \"To\"  \"linux-drift@uio.no\") 	    	       (header-matches \"Cc\"  \"linux-drift@uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-38", " (or    	(match-all (or (header-contains \"To\"  \"drift@uninett.no\") 	               (header-contains \"Cc\"  \"drift@uninett.no\")))          	(match-all (or (header-contains \"To\"  \"drift-info@uninett.no\") 	               (header-contains \"Cc\"  \"drift-info@uninett.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-39", " (match-threads \"replies_parents\"  (or            (match-all (or (header-starts-with \"To\"  \"kjetilho\") 	    	       (header-starts-with \"Cc\"  \"kjetilho\")))          	(match-all (or (header-matches \"To\"  \"kjetilth@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"kjetilth@ifi.uio.no\")))         ) ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-40", " (or    	(match-all (or (header-matches \"To\"  \"11m@l.olafsen.org\") 	    	       (header-matches \"Cc\"  \"11m@l.olafsen.org\")))         (match-all (header-contains \"From\"  \"11mod.info\"))    	(match-all (or (header-contains \"To\"  \"11mod.info\") 	               (header-contains \"Cc\"  \"11mod.info\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-41", " (and    	(match-all (or (header-matches \"To\"  \"bash-testers@cwru.edu\") 	    	       (header-matches \"Cc\"  \"bash-testers@cwru.edu\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-42", " (and    	(match-all (or (header-matches \"To\"  \"bsd@linpro.no\") 	    	       (header-matches \"Cc\"  \"bsd@linpro.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-43", " (and   (match-all (header-contains \"From\"  \"bugzilla-daemon\"))   ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-44", " (or    	(match-all (or (header-matches \"To\"  \"info-cyrus@lists.andrew.cmu.edu\") 	    	       (header-matches \"Cc\"  \"info-cyrus@lists.andrew.cmu.edu\")))          	(match-all (or (header-matches \"To\"  \"info-cyrus@andrew.cmu.edu\") 	    	       (header-matches \"Cc\"  \"info-cyrus@andrew.cmu.edu\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-45", " (or    	(match-all (or (header-matches \"To\"  \"cyrus-sasl@lists.andrew.cmu.edu\") 	    	       (header-matches \"Cc\"  \"cyrus-sasl@lists.andrew.cmu.edu\")))          	(match-all (or (header-matches \"To\"  \"cyrus-sasl@andrew.cmu.edu\") 	    	       (header-matches \"Cc\"  \"cyrus-sasl@andrew.cmu.edu\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-46", " (or    	(match-all (or (header-matches \"To\"  \"evolution@lists.ximian.com\") 	    	       (header-matches \"Cc\"  \"evolution@lists.ximian.com\")))          	(match-all (or (header-matches \"To\"  \"evolution@ximian.com\") 	    	       (header-matches \"Cc\"  \"evolution@ximian.com\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-47", " (or    	(match-all (or (header-matches \"To\"  \"evolution-hackers@lists.ximian.com\") 	    	       (header-matches \"Cc\"  \"evolution-hackers@lists.ximian.com\")))          	(match-all (or (header-matches \"To\"  \"evolution-hackers@ximian.com\") 	    	       (header-matches \"Cc\"  \"evolution-hackers@ximian.com\")))          	(match-all (or (header-matches \"To\"  \"evolution-hackers@ximian.org\") 	    	       (header-matches \"Cc\"  \"evolution-hackers@ximian.org\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-48", " (or    	(match-all (or (header-matches \"To\"  \"exim-users@exim.org\") 	    	       (header-matches \"Cc\"  \"exim-users@exim.org\")))          	(match-all (or (header-matches \"To\"  \"exim-dev@exim.org\") 	    	       (header-matches \"Cc\"  \"exim-dev@exim.org\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-49", " (and    	(match-all (or (header-matches \"To\"  \"i18n-nn@lister.ping.uio.no\") 	    	       (header-matches \"Cc\"  \"i18n-nn@lister.ping.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-50", " (and    	(match-all (or (header-matches \"To\"  \"i18n-no@lister.ping.uio.no\") 	    	       (header-matches \"Cc\"  \"i18n-no@lister.ping.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-51", " (or    	(match-all (or (header-matches \"To\"  \"ietf-mta-filters@imc.org\") 	    	       (header-matches \"Cc\"  \"ietf-mta-filters@imc.org\")))          	(match-all (or (header-matches \"To\"  \"ietf-mta-filters@mail.imc.org\") 	    	       (header-matches \"Cc\"  \"ietf-mta-filters@mail.imc.org\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-52", " (and    	(match-all (or (header-matches \"To\"  \"iml@math.uio.no\") 	    	       (header-matches \"Cc\"  \"iml@math.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-53", " (or    	(match-all (or (header-matches \"To\"  \"jofi@l.olafsen.org\") 	    	       (header-matches \"Cc\"  \"jofi@l.olafsen.org\")))          	(match-all (or (header-matches \"To\"  \"varsel@l.olafsen.org\") 	    	       (header-matches \"Cc\"  \"varsel@l.olafsen.org\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-54", " (and    	(match-all (or (header-matches \"To\"  \"keepalived-devel@lists.sourceforge.net\") 	    	       (header-matches \"Cc\"  \"keepalived-devel@lists.sourceforge.net\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-55", " (and    	(match-all (or (header-matches \"To\"  \"lvs-users@linuxvirtualserver.org\") 	    	       (header-matches \"Cc\"  \"lvs-users@linuxvirtualserver.org\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-56", " (and    	(match-all (or (header-matches \"To\"  \"porsche@yahoogroups.com\") 	    	       (header-matches \"Cc\"  \"porsche@yahoogroups.com\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-57", " (or    	(match-all (or (header-matches \"To\"  \"gurpserne@studorg.uio.no\") 	    	       (header-matches \"Cc\"  \"gurpserne@studorg.uio.no\")))          	(match-all (or (header-matches \"To\"  \"warhammer@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"warhammer@ifi.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-58", " (or    	(match-all (or (header-matches \"To\"  \"sycophant@smoe.org\") 	    	       (header-matches \"Cc\"  \"sycophant@smoe.org\")))          	(match-all (or (header-matches \"To\"  \"sycophant@ecto.org\") 	    	       (header-matches \"Cc\"  \"sycophant@ecto.org\")))         ) ", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "vfolder-59", " (or    	(match-all (or (header-matches \"To\"  \"eiere@linpro.no\") 	    	       (header-matches \"Cc\"  \"eiere@linpro.no\")))          	(match-all (or (header-matches \"To\"  \"rom-utvalget@ifi.uio.no\") 	    	       (header-matches \"Cc\"  \"rom-utvalget@ifi.uio.no\")))          	(match-all (or (header-matches \"To\"  \"fvwm-announce@fvwm.org\") 	    	       (header-matches \"Cc\"  \"fvwm-announce@fvwm.org\")))          	(match-all (or (header-matches \"To\"  \"bash-testers@po.cwru.edu\") 	    	       (header-matches \"Cc\"  \"bash-testers@po.cwru.edu\")))                  (match-all (or (header-ends-with \"To\"  \"bilkollektivet.no\") 	    	       (header-ends-with \"Cc\"  \"bilkollektivet.no\")))                  (match-all (or (header-ends-with \"To\"  \"nuug.no\") 	    	       (header-ends-with \"Cc\"  \"nuug.no\")))          	(match-all (or (header-matches \"To\"  \"mandagspils@simula.org\") 	    	       (header-matches \"Cc\"  \"mandagspils@simula.org\")))                  (match-all (or (header-ends-with \"To\"  \"duggfrisk.org\") 	    	       (header-ends-with \"Cc\"  \"duggfrisk.org\")))          	(match-all (or (header-matches \"To\"  \"praha-gutta@usit.uio.no\") 	    	       (header-matches \"Cc\"  \"praha-gutta@usit.uio.no\")))         ) ", &ex);
	camel_exception_clear(&ex);
}

CamelFolderSummaryDisk *
camel_folder_summary_disk_construct(CamelFolderSummaryDisk *cds, struct _CamelFolder *folder)
{
	CamelFolderSummary *s = (CamelFolderSummary *)cds;
	CamelException ex = { 0 };

	s->folder = folder;
	s->view_summary = folder->parent_store->view_summary;
	camel_object_ref(s->view_summary);

	printf("Setting up summary for '%s'\n", folder->full_name);

	/* todo: make this overridable, setup in init func probably */
	s->search = camel_folder_search_new();

	cds_load_views(cds, NULL, &ex);
	if (ex.id) {
		g_warning("summary construct failed: %s", ex.desc);
		return NULL;
	}

	/* We init these extra views after loading the header data, if we already had them, this means
	   they will just be ignored now, if we set them up before, it means we'd lose the counts */

	camel_folder_view_create(s, "#.trash", "(system-flag \"Deleted\")", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "#.junk", "(system-flag \"Junk\")", &ex);
	camel_exception_clear(&ex);

//	setup_views(s);
#if 0
	/* add some 'vfolders' */
	camel_folder_view_create(s, "unread", "(not (system-flag \"Seen\"))", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "evolution-hackers", "(header-contains \"subject\" \"[evolution-hackers]\")", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "evolution", "(header-contains \"subject\" \"[hackers]\")", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "to.notzed", "(header-contains \"to\" \"notzed\")", &ex);
	camel_exception_clear(&ex);
	camel_folder_view_create(s, "from.notzed", "(header-contains \"from\" \"notzed\")", &ex);
	camel_exception_clear(&ex);
#endif
	/* Now build any views we need to at all at once */
	cds_view_build_all(cds, &ex);
	camel_exception_clear(&ex);

	/* sync? */

	return cds;
}

CamelFolderSummaryDisk *
camel_folder_summary_disk_new(struct _CamelFolder *folder)
{
	CamelFolderSummaryDisk *cds = (CamelFolderSummaryDisk *)camel_object_new(camel_folder_summary_disk_get_type());

	return camel_folder_summary_disk_construct(cds, folder);
}

/* ********************************************************************** */

static int
cds_get_changed(void *k, void *v, void *d)
{
	GPtrArray *infos = d;

	g_ptr_array_add(infos, v);

	return TRUE;
}

static int
cds_array_info_cmp(const void *ap, const void *bp, void *data)
{
	const CamelMessageInfo *a = ((const CamelMessageInfo **)ap)[0];
	const CamelMessageInfo *b = ((const CamelMessageInfo **)bp)[0];

	return CFS_CLASS(data)->info_cmp(a, b, data);
}

void
camel_folder_summary_disk_sync(CamelFolderSummaryDisk *cds, CamelException *ex)
{
	struct _CamelFolderSummaryDiskPrivate *p = _PRIVATE(cds);
	GPtrArray *infos;
	int i;

	infos = g_ptr_array_new();
	CAMEL_SUMMARY_LOCK(cds, ref_lock);
	g_hash_table_foreach_remove(p->changed, cds_get_changed, infos);
	CAMEL_SUMMARY_UNLOCK(cds, ref_lock);

	/* sorted for your convenience */
	g_qsort_with_data(infos->pdata, infos->len, sizeof(infos->pdata[0]), cds_array_info_cmp, cds);

	CDS_CLASS(cds)->sync(cds, infos, ex);

	for (i=0;i<infos->len;i++)
		camel_message_info_free(infos->pdata[i]);
	g_ptr_array_free(infos, TRUE);
}

/* Internal accessor for an iterator from this summary.

   This is only valid for iterators that came from a search on this
   summary, with no expression and no subset iterator.  It can be used
   only by subclasses for finer control of the cursor.

   flags0 are the flags to go to the next record, and flags1 to
   go to the next one after that, if the first one is empty/invalid.

   e.g. use DB_LAST, DB_PREV to get the last record

   This needs more thought, we should be able to skip to any record as well
*/

const CamelMessageInfo *camel_message_iterator_disk_get(void *mitin, guint32 flags0, guint32 flags1, CamelException *ex)
{
	// FIXME: this doesn't actually work!

	return cds_iterator_step(mitin, flags0, flags1, ex);
}
